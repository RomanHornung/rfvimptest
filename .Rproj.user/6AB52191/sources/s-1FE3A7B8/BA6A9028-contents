
library(permimp)
library(party)

allinone <- function(object, mod_call, M = 500, varnames = NULL, p0 = 0.06, p1 = 0.04, alpha = 0.05, beta = 0.2, A = 0.1, B = 10, h = 8, nperm = 1, ...) {
  starttime <- Sys.time()

  # Define the parameters A and B for SPRT and SAPT
  A_SPRT <- beta / (1 - alpha)
  B_SPRT <- (1 - beta) / alpha

  logA_SPRT <- log(A_SPRT)
  logB_SPRT <- log(B_SPRT)

  logA_SAPT <- log(A)
  logB_SAPT <- log(B)

  # Define the stopping criteria
  help1 <- log((1 - p0) / (1 - p1))
  help2 <- log((p1 * (1 - p0)) / (p0 * (1 - p1)))

  stop_crits <- list(SPRT = list((logA_SPRT + 1:M * help1) / help2, (logB_SPRT + 1:M * help1) / help2),
                     SAPT = list((logA_SAPT + 1:M * help1) / help2, (logB_SAPT + 1:M * help1) / help2),
                     certain = list(rep(alpha*M, times = M), M*alpha - M + 1:M))

  # Extract data and variable information from model
  data <- cbind(object@data@get("response"), object@data@get("input"))
  yname <- as.character(object@data@formula$response[-1])
  xnames <- gsub(" ", "", unlist(strsplit(as.character(object@data@formula$input[-1]), "\\+")))
  if (is.null(varnames)) varnames <- xnames

  # Calculate VIMP
  vimp_orig <- permimp(object, whichxnames = varnames, nperm = nperm, ..., asParty = TRUE, progressBar = FALSE)

  # Some preparation of the permutation
  permod_call <- mod_call
  permod_call$data <- quote(permdat)

  ntrees <- length(object@ensemble)

  # The computations for each variable
  testresult <- lapply(varnames, function(v) {
    # copy data for permutation
    permdat <- data
    permvimps <- rep(NA, M)

    # do the permutations of the gereral permutation test
    for (m in 1:M) {
      permdat[, v] <- sample(permdat[, v])
      permmod <- eval(permod_call)

      permmodvimps <- permimp(permmod, whichxnames = v, nperm = nperm, ..., asParty = TRUE, progressBar = FALSE)
      permvimps[m] <- permmodvimps$values
    }

    # compute d along the sequence 1:M and the p-value of COMPLETE
    d <- cumsum(permvimps >= vimp_orig$values[v])
    pval <- rev(d)[1] / M

    # apply the stopping criteria for each method to d
    m1_SPRT <- which(d >= stop_crits[[1]][[1]])[1]
    m2_SPRT <- which(d <= stop_crits[[1]][[2]])[1]

    # if a method does not stop early m is set to M+1 for ease of further processing
    if (is.na(m1_SPRT)) m1_SPRT <- M + 1
    if (is.na(m2_SPRT)) m2_SPRT <- M + 1

    m1_SAPT <- which(d >= stop_crits[[2]][[1]])[1]
    m2_SAPT <- which(d <= stop_crits[[2]][[2]])[1]

    if (is.na(m1_SAPT)) m1_SAPT <- M + 1
    if (is.na(m2_SAPT)) m2_SAPT <- M + 1

    m_PVAL <- which(d == h)[1]

    if (is.na(m_PVAL)) m_PVAL <- M + 1

    m1_CERTAIN <- which(d > stop_crits[[3]][[1]])[1]
    m2_CERTAIN <- which(d <= stop_crits[[3]][[2]])[1]

    if (is.na(m1_CERTAIN)) m1_CERTAIN <- M + 1
    if (is.na(m2_CERTAIN)) m2_CERTAIN <- M + 1


    # Repeat all steps for the two-sample test
    permvimps_TS <- rep(NA, M)

    for (m in 1:M) {
      permvimps_TS[m] <- mean(c(vimp_orig$perTree[, v], permmodvimps$perTree[, v])[sample(1:(2*ntrees), ntrees)])
    }

    d_TS <- cumsum(permvimps_TS >= vimp_orig$values[v])
    pval_TS <- rev(d_TS)[1] / M

    m1_SPRT_TS <- which(d_TS >= stop_crits[[1]][[1]])[1]
    m2_SPRT_TS <- which(d_TS <= stop_crits[[1]][[2]])[1]

    if (is.na(m1_SPRT_TS)) m1_SPRT_TS <- M + 1
    if (is.na(m2_SPRT_TS)) m2_SPRT_TS <- M + 1

    m1_SAPT_TS <- which(d_TS >= stop_crits[[2]][[1]])[1]
    m2_SAPT_TS <- which(d_TS <= stop_crits[[2]][[2]])[1]

    if (is.na(m1_SAPT_TS)) m1_SAPT_TS <- M + 1
    if (is.na(m2_SAPT_TS)) m2_SAPT_TS <- M + 1

    m_PVAL_TS <- which(d_TS == h)[1]

    if (is.na(m_PVAL_TS)) m_PVAL_TS <- M + 1

    m1_CERTAIN_TS <- which(d_TS > stop_crits[[3]][[1]])[1]
    m2_CERTAIN_TS <- which(d_TS <= stop_crits[[3]][[2]])[1]

    if (is.na(m1_CERTAIN_TS)) m1_CERTAIN_TS <- M + 1
    if (is.na(m2_CERTAIN_TS)) m2_CERTAIN_TS <- M + 1


    # Create a matrix of results
    cbind(c("SPRT", "SAPT", "PVAL", "CERTAIN", "COMPLETE", "SPRT_TS", "SAPT_TS", "PVAL_TS", "CERTAIN_TS", "COMPLETE_TS"),
          rbind(
            SPRT = if (any(c(m1_SPRT, m2_SPRT) < M)) {c(c("accept H0", "accept H1")[which.min(c(m1_SPRT, m2_SPRT))], c(m1_SPRT, m2_SPRT)[which.min(c(m1_SPRT, m2_SPRT))])} else {c(pval, M)},
            SAPT = if (any(c(m1_SAPT, m2_SAPT) < M)) {c(c("accept H0", "accept H1")[which.min(c(m1_SAPT, m2_SAPT))], c(m1_SAPT, m2_SAPT)[which.min(c(m1_SAPT, m2_SAPT))])} else {c(pval, M)},
            PVAL = if (m_PVAL <= M) {c(h / m_PVAL, m_PVAL)} else {c((rev(d)[1] + 1) / (M + 1), M)},
            CERTAIN = if (any(c(m1_CERTAIN, m2_CERTAIN) < M)) {c(c("accept H0", "accept H1")[which.min(c(m1_CERTAIN, m2_CERTAIN))], c(m1_CERTAIN, m2_CERTAIN)[which.min(c(m1_CERTAIN, m2_CERTAIN))])} else {c(pval, M)},
            COMPLETE = c(pval, M),
            SPRT_TS = if (any(c(m1_SPRT_TS, m2_SPRT_TS) < M)) {c(c("accept H0", "accept H1")[which.min(c(m1_SPRT_TS, m2_SPRT_TS))], c(m1_SPRT_TS, m2_SPRT_TS)[which.min(c(m1_SPRT_TS, m2_SPRT_TS))])} else {c(pval_TS, M)},
            SAPT_TS = if (any(c(m1_SAPT_TS, m2_SAPT_TS) < M)) {c(c("accept H0", "accept H1")[which.min(c(m1_SAPT_TS, m2_SAPT_TS))], c(m1_SAPT_TS, m2_SAPT_TS)[which.min(c(m1_SAPT_TS, m2_SAPT_TS))])} else {c(pval_TS, M)},
            PVAL_TS = if (m_PVAL_TS <= M) {c(h / m_PVAL_TS, m_PVAL_TS)} else {c((rev(d_TS)[1] + 1) / (M + 1), M)},
            CERTAIN_TS = if (any(c(m1_CERTAIN_TS, m2_CERTAIN_TS) < M)) {c(c("accept H0", "accept H1")[which.min(c(m1_CERTAIN_TS, m2_CERTAIN_TS))], c(m1_CERTAIN_TS, m2_CERTAIN_TS)[which.min(c(m1_CERTAIN_TS, m2_CERTAIN_TS))])} else {c(pval_TS, M)},
            COMPLETE_TS = c(pval_TS, M)
    ))
  })

testresult <- cbind(rep(varnames, each = 10), do.call(rbind, testresult))

stoptime <- Sys.time()
time_elapsed <- difftime(stoptime, starttime, units = "secs")

return(list(testresult, time_elapsed))
}


